# Оптимизация загрузки данных и отзывчивости UI

Этот документ фиксирует то, что уже сделано для ускорения приложения, и даёт рекомендации для дальнейших улучшений.

## Что уже сделано

- Кеш‑первый показ проектов
  - Показ проектов из LocalStorage мгновенно, затем фоновая подгрузка из Supabase и обновление кеша.
  - Реализация: `src/hooks/useProjects.ts`
    - Чтение кеша при монтировании и `setProjects(cached)`
    - Сохранение актуальных данных в кеш после загрузки

- Параллельная загрузка данных при активной сессии
  - Загрузки проектов, документов, фотоотчётов, смет, инвентаря, заметок и задач выполняются через `Promise.all`.
  - Реализация: `src/App.tsx` блок загрузки по `session`.

- Индексы в БД для горячих запросов
  - Файл: `sql/perf_indexes.sql`
  - Индексы:
    - `finance_entries(user_id, project_id, created_at desc)`
    - `finance_entries(user_id, date desc)`
    - `documents(user_id, project_id, created_at desc)`
    - `estimates(user_id, created_at desc)`
    - `estimate_items(estimate_id)`
    - `work_stages(user_id, project_id, start_date)`
  - В случае ошибок редактора Supabase используйте DO‑блоки с проверкой существования колонок (см. инструкции в переписке).

## Что ещё рекомендую внедрить

1) Кеш‑первый показ для остальных сущностей
   - Аналогично проектам: сначала читаем из LocalStorage, сразу отображаем; после успешной загрузки из Supabase — обновляем Store и кеш.
   - Кандидаты: `estimates`, `tasks`, `notes`, `inventory`.

2) Lazy‑loading/сужение payload
   - Для смет: тянуть список смет (id, number, date, status, project_id) без `estimate_items`, а позиции догружать по открытию конкретной сметы.
   - Для больших списков: ограничивать `select` только нужными полями, добавлять пагинацию (`range`, `limit`).

3) Realtime‑синхронизация
   - Включить Realtime на таблицах (`finance_entries`, `documents`, `work_stages`, `estimates`).
   - В коде подписываться на изменения (insert/update/delete) и обновлять локальное состояние. Это устранит необходимость явных `refetch` и даст мгновенную консистентность между вкладками.

4) Кеш на IndexedDB для тяжёлых данных
   - Если LocalStorage окажется тесен/медленен для крупных коллекций — перенести кеширование в IndexedDB (например, через `idb-keyval`).

5) UI‑ускорители
   - Скелетоны вместо "пустых" экранов, пока идёт фоновая загрузка — даёт ощущение мгновенного старта.
   - Виртуализация больших списков (например, задачи/сметы) при очень длинных выборках.
   - `React.memo`/`useMemo`/`useCallback` на компонентах/вычислениях, которые часто перерендериваются.

6) Регулярный аудит индексов
   - В Supabase → Explorer → Query Performance проверять, что запросы используют индексы.
   - Добавлять/корректировать индексы по реальным фильтрам/сортировкам.

## Чек‑лист внедрения (что нужно сделать на стороне Supabase)

1. Выполнить SQL из `sql/perf_indexes.sql` (или по одному DO‑блоку, если редактор возмущается).
2. (Опционально) Включить Realtime на таблицах: `finance_entries`, `documents`, `work_stages`, `estimates`.
3. Проверить, что колонки в таблицах совпадают с индексируемыми (например, `created_at`, `date`). Если названия отличаются — скорректировать индекс под фактические поля.

## План на будущее (могу реализовать по запросу)

- Добавить кеш‑первый показ для смет/задач/заметок/инвентаря.
- Разделить загрузку смет (без `items`) и догружать позиции по требованию.
- Добавить Realtime‑подписки и обработчики в хуки данных.
- Провести лёгкую виртуализацию списков, если объём данных растёт.

